res <- online_SG(initpar, rate, cb = online_loglogis_SG_tracer$tracer)
summary(online_loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
View(trueval_tibble)
trueval_tibble(Parameter = c("alpha", "beta", "gamma", "rho"), c(alpha0, beta0, gamma0, rho0))
library(tidyverse)
ggplot2::theme_set(theme_bw())
library(microbenchmark)
library(profvis)
library(Rcpp)
library(splines)
library(xtable)
library(numDeriv)
library(CSwR)
## Key-functions ##
#Density
densY <- function(x, alpha, beta, gamma, rho){
gamma + (rho-gamma)/(1+exp(beta*x-alpha))
}
# Nonlinear least squares
#Gradient
grad_calc <- function(x, y, alpha, beta, gamma, rho){
N <- length(x)
grad_alpha <- 2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
((gamma-rho)*exp(beta*x-alpha))/((exp(beta*x-alpha)+1)^2)
)
grad_beta <- -2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
((gamma-rho)*x*exp(beta*x-alpha))/((exp(beta*x-alpha)+1)^2)
)
grad_gamma <- 2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
(1/(1+exp(beta*x-alpha))-1)
)
grad_rho <- -2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
(1/(1+exp(beta*x-alpha)))
)
c(grad_alpha, grad_beta, grad_gamma, grad_rho)
}
#True parameters
alpha0 <- 1
beta0 <- 2
gamma0 <- 5
rho0 <- 2
trueval_tibble <- tibble(Parameter = c("alpha", "beta", "gamma", "rho"), c(alpha0, beta0, gamma0, rho0))
# Sim parameters
sigma <- 0.1
omega <- 5
# Grad-test
test_points <- c(1,1)
obj_func <- function(x, y, param){
1/length(x)*(sum((y-densY(x, param[1], param[2], param[3], param[4]))^2))
}
obj_func_test <- function(param){
1/length(test_points[1])*(sum((test_points[2]-densY(test_points[1], param[1], param[2], param[3], param[4]))^2))
}
grad_calc(test_points[1], test_points[2], alpha0, beta0, gamma0, rho0)
numDeriv::grad(obj_func_test, x = c(alpha0, beta0, gamma0, rho0))
decay_scheduler <- function(gamma1 = 1, a = 1, K = 1, gamma2, n1) {
force(a)
if (!missing(gamma2) && !missing(n1))
K <- n1^a * gamma2 / (gamma0 - gamma2)
b <- gamma1 * K
function(n) b / (K + n^a)
}
rate <- decay_scheduler(gamma1 = 0.5, K = 100)
# Online learning
initpar <- c(alpha0, beta0, gamma0, rho0)
online_SG <- function(
par0,
gamma,
maxiter = 10000,
cb = NULL,
...
){
gamma <- if(is.function(gamma))gamma(1:maxiter) else rep(gamma, (maxiter))
par <- par0
for (i in 1:maxiter){
if(!is.null(cb)) cb()
# Simulate online data
X <- rnorm(1, mean = 0, sd = omega)
epsilon <- rnorm(1, mean = 0, sd = sigma)
Y <- densY(X, alpha0, beta0, gamma0, rho0) + epsilon
par <- par - gamma[i] * grad_calc(X, Y, par[1],par[2], par[3], par[4])
}
par
}
online_loglogis_SG_tracer <- tracer("par", N = 0)
res <- online_SG(initpar, rate, cb = online_loglogis_SG_tracer$tracer)
summary(online_loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
trueval_tibble <- tibble(Parameter = c("alpha", "beta", "gamma", "rho"), Value = c(alpha0, beta0, gamma0, rho0))
decay_scheduler <- function(gamma1 = 1, a = 1, K = 1, gamma2, n1) {
force(a)
if (!missing(gamma2) && !missing(n1))
K <- n1^a * gamma2 / (gamma0 - gamma2)
b <- gamma1 * K
function(n) b / (K + n^a)
}
rate <- decay_scheduler(gamma1 = 0.5, K = 100)
# Online learning
initpar <- c(alpha0, beta0, gamma0, rho0)
online_SG <- function(
par0,
gamma,
maxiter = 10000,
cb = NULL,
...
){
gamma <- if(is.function(gamma))gamma(1:maxiter) else rep(gamma, (maxiter))
par <- par0
for (i in 1:maxiter){
if(!is.null(cb)) cb()
# Simulate online data
X <- rnorm(1, mean = 0, sd = omega)
epsilon <- rnorm(1, mean = 0, sd = sigma)
Y <- densY(X, alpha0, beta0, gamma0, rho0) + epsilon
par <- par - gamma[i] * grad_calc(X, Y, par[1],par[2], par[3], par[4])
}
par
}
online_loglogis_SG_tracer <- tracer("par", N = 0)
res <- online_SG(initpar, rate, cb = online_loglogis_SG_tracer$tracer)
summary(online_loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
library(tidyverse)
ggplot2::theme_set(theme_bw())
library(microbenchmark)
library(profvis)
library(Rcpp)
library(splines)
library(xtable)
library(numDeriv)
library(CSwR)
## Key-functions ##
#Density
densY <- function(x, alpha, beta, gamma, rho){
gamma + (rho-gamma)/(1+exp(beta*x-alpha))
}
# Nonlinear least squares
#Gradient
grad_calc <- function(x, y, alpha, beta, gamma, rho){
N <- length(x)
grad_alpha <- 2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
((gamma-rho)*exp(beta*x-alpha))/((exp(beta*x-alpha)+1)^2)
)
grad_beta <- -2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
((gamma-rho)*x*exp(beta*x-alpha))/((exp(beta*x-alpha)+1)^2)
)
grad_gamma <- 2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
(1/(1+exp(beta*x-alpha))-1)
)
grad_rho <- -2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
(1/(1+exp(beta*x-alpha)))
)
c(grad_alpha, grad_beta, grad_gamma, grad_rho)
}
#True parameters
alpha0 <- 1
beta0 <- 2
gamma0 <- 1
rho0 <- 1
trueval_tibble <- tibble(Parameter = c("alpha", "beta", "gamma", "rho"), Value = c(alpha0, beta0, gamma0, rho0))
# Sim parameters
sigma <- 0.1
omega <- 5
# Grad-test
test_points <- c(1,1)
obj_func <- function(x, y, param){
1/length(x)*(sum((y-densY(x, param[1], param[2], param[3], param[4]))^2))
}
obj_func_test <- function(param){
1/length(test_points[1])*(sum((test_points[2]-densY(test_points[1], param[1], param[2], param[3], param[4]))^2))
}
grad_calc(test_points[1], test_points[2], alpha0, beta0, gamma0, rho0)
numDeriv::grad(obj_func_test, x = c(alpha0, beta0, gamma0, rho0))
decay_scheduler <- function(gamma1 = 1, a = 1, K = 1, gamma2, n1) {
force(a)
if (!missing(gamma2) && !missing(n1))
K <- n1^a * gamma2 / (gamma0 - gamma2)
b <- gamma1 * K
function(n) b / (K + n^a)
}
rate <- decay_scheduler(gamma1 = 0.5, K = 100)
# Online learning
initpar <- c(alpha0, beta0, gamma0, rho0)
online_SG <- function(
par0,
gamma,
maxiter = 10000,
cb = NULL,
...
){
gamma <- if(is.function(gamma))gamma(1:maxiter) else rep(gamma, (maxiter))
par <- par0
for (i in 1:maxiter){
if(!is.null(cb)) cb()
# Simulate online data
X <- rnorm(1, mean = 0, sd = omega)
epsilon <- rnorm(1, mean = 0, sd = sigma)
Y <- densY(X, alpha0, beta0, gamma0, rho0) + epsilon
par <- par - gamma[i] * grad_calc(X, Y, par[1],par[2], par[3], par[4])
}
par
}
online_loglogis_SG_tracer <- tracer("par", N = 0)
res <- online_SG(initpar, rate, cb = online_loglogis_SG_tracer$tracer)
summary(online_loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
library(tidyverse)
ggplot2::theme_set(theme_bw())
library(microbenchmark)
library(profvis)
library(Rcpp)
library(splines)
library(xtable)
library(numDeriv)
library(CSwR)
## Key-functions ##
#Density
densY <- function(x, alpha, beta, gamma, rho){
gamma + (rho-gamma)/(1+exp(beta*x-alpha))
}
# Nonlinear least squares
#Gradient
grad_calc <- function(x, y, alpha, beta, gamma, rho){
N <- length(x)
grad_alpha <- 2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
((gamma-rho)*exp(beta*x-alpha))/((exp(beta*x-alpha)+1)^2)
)
grad_beta <- -2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
((gamma-rho)*x*exp(beta*x-alpha))/((exp(beta*x-alpha)+1)^2)
)
grad_gamma <- 2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
(1/(1+exp(beta*x-alpha))-1)
)
grad_rho <- -2/N*sum(
(y-gamma+(gamma-rho)/(1+exp(beta*x-alpha)))*
(1/(1+exp(beta*x-alpha)))
)
c(grad_alpha, grad_beta, grad_gamma, grad_rho)
}
#True parameters
alpha0 <- 1
beta0 <- 0.5
gamma0 <- -0.5
rho0 <- -1
trueval_tibble <- tibble(Parameter = c("alpha", "beta", "gamma", "rho"), Value = c(alpha0, beta0, gamma0, rho0))
# Sim parameters
sigma <- 0.1
omega <- 5
# Grad-test
test_points <- c(1,1)
obj_func <- function(x, y, param){
1/length(x)*(sum((y-densY(x, param[1], param[2], param[3], param[4]))^2))
}
obj_func_test <- function(param){
1/length(test_points[1])*(sum((test_points[2]-densY(test_points[1], param[1], param[2], param[3], param[4]))^2))
}
grad_calc(test_points[1], test_points[2], alpha0, beta0, gamma0, rho0)
numDeriv::grad(obj_func_test, x = c(alpha0, beta0, gamma0, rho0))
decay_scheduler <- function(gamma1 = 1, a = 1, K = 1, gamma2, n1) {
force(a)
if (!missing(gamma2) && !missing(n1))
K <- n1^a * gamma2 / (gamma0 - gamma2)
b <- gamma1 * K
function(n) b / (K + n^a)
}
rate <- decay_scheduler(gamma1 = 0.5, K = 100)
# Online learning
initpar <- c(alpha0, beta0, gamma0, rho0)
online_SG <- function(
par0,
gamma,
maxiter = 10000,
cb = NULL,
...
){
gamma <- if(is.function(gamma))gamma(1:maxiter) else rep(gamma, (maxiter))
par <- par0
for (i in 1:maxiter){
if(!is.null(cb)) cb()
# Simulate online data
X <- rnorm(1, mean = 0, sd = omega)
epsilon <- rnorm(1, mean = 0, sd = sigma)
Y <- densY(X, alpha0, beta0, gamma0, rho0) + epsilon
par <- par - gamma[i] * grad_calc(X, Y, par[1],par[2], par[3], par[4])
}
par
}
online_loglogis_SG_tracer <- tracer("par", N = 0)
res <- online_SG(initpar, rate, cb = online_loglogis_SG_tracer$tracer)
summary(online_loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
# Batch stochastic gradient algorithm
# Simulation
N <- 5000
X <- rnorm(N, mean = 0, sd = omega)
epsilon <- rnorm(N, mean = 0, sd = sigma)
Y <- densY(X, alpha0, beta0, gamma0, rho0) + epsilon
SG <- function(
par,
N,
gamma,
maxiter = 100,
sampler = sample,
cb = NULL,
...
){
gamma <- if(is.function(gamma))gamma(1:maxiter) else rep(gamma, maxiter)
for (k in 1:maxiter){
if(!is.null(cb)) cb()
samp <- sampler(N)
for (j in 1:N){
i <- samp[j]
par <- par - gamma[k] * grad_calc(X[i], Y[i], par[1], par[2], par[3], par[4])
}
}
par
}
# Tracing
loglogis_SG_tracer <- tracer("par", N = 0)
res <- SG(initpar,
N = N,
gamma = rate,
cb = loglogis_SG_tracer$tracer)
# Plot estimates against true values
summary(loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
# Objective function
SG_mini <- function(
par,
N,
gamma,
epoch = batch,
...,
maxiter = 100,
sampler = sample,
cb = NULL
) {
gamma <- if (is.function(gamma)) gamma(1:maxiter) else rep(gamma, maxiter)
for(k in 1:maxiter) {
if(!is.null(cb)) cb()
samp <- sampler(N)
par <- epoch(par, samp, gamma[k], ...)
}
par
}
batch <- function(
par,
samp,
gamma,
m = 50,            # Mini-batch size
...
) {
M <- floor(length(samp) / m)
for(j in 0:(M - 1)) {
i <- samp[(j * m + 1):(j * m + m)]
par <- par - gamma * grad_calc(X[i], Y[i], par[1], par[2], par[3], par[4])
}
par
}
SG_tracer <- tracer("par", N = 0)
SG_mini(initpar,
N = length(X),
gamma = 5e-2,
maxiter = 200,
cb = SG_tracer$tracer
)
summary(SG_tracer)
summary(SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
initpar <- c(alpha0 + runif(1,-1,1), beta0 + runif(1,-1,1), gamma0 + runif(1,-1,1), rho0 + runif(1,-1,1))
decay_scheduler <- function(gamma1 = 1, a = 1, K = 1, gamma2, n1) {
force(a)
if (!missing(gamma2) && !missing(n1))
K <- n1^a * gamma2 / (gamma0 - gamma2)
b <- gamma1 * K
function(n) b / (K + n^a)
}
rate <- decay_scheduler(gamma1 = 0.5, K = 100)
# Online learning
initpar <- c(alpha0 + runif(1,-1,1), beta0 + runif(1,-1,1), gamma0 + runif(1,-1,1), rho0 + runif(1,-1,1))
online_SG <- function(
par0,
gamma,
maxiter = 10000,
cb = NULL,
...
){
gamma <- if(is.function(gamma))gamma(1:maxiter) else rep(gamma, (maxiter))
par <- par0
for (i in 1:maxiter){
if(!is.null(cb)) cb()
# Simulate online data
X <- rnorm(1, mean = 0, sd = omega)
epsilon <- rnorm(1, mean = 0, sd = sigma)
Y <- densY(X, alpha0, beta0, gamma0, rho0) + epsilon
par <- par - gamma[i] * grad_calc(X, Y, par[1],par[2], par[3], par[4])
}
par
}
online_loglogis_SG_tracer <- tracer("par", N = 0)
res <- online_SG(initpar, rate, cb = online_loglogis_SG_tracer$tracer)
summary(online_loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
# Batch stochastic gradient algorithm
# Simulation
N <- 5000
X <- rnorm(N, mean = 0, sd = omega)
epsilon <- rnorm(N, mean = 0, sd = sigma)
Y <- densY(X, alpha0, beta0, gamma0, rho0) + epsilon
SG <- function(
par,
N,
gamma,
maxiter = 100,
sampler = sample,
cb = NULL,
...
){
gamma <- if(is.function(gamma))gamma(1:maxiter) else rep(gamma, maxiter)
for (k in 1:maxiter){
if(!is.null(cb)) cb()
samp <- sampler(N)
for (j in 1:N){
i <- samp[j]
par <- par - gamma[k] * grad_calc(X[i], Y[i], par[1], par[2], par[3], par[4])
}
}
par
}
# Tracing
loglogis_SG_tracer <- tracer("par", N = 0)
res <- SG(initpar,
N = N,
gamma = rate,
cb = loglogis_SG_tracer$tracer)
# Plot estimates against true values
summary(loglogis_SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
# Objective function
SG_mini <- function(
par,
N,
gamma,
epoch = batch,
...,
maxiter = 100,
sampler = sample,
cb = NULL
) {
gamma <- if (is.function(gamma)) gamma(1:maxiter) else rep(gamma, maxiter)
for(k in 1:maxiter) {
if(!is.null(cb)) cb()
samp <- sampler(N)
par <- epoch(par, samp, gamma[k], ...)
}
par
}
batch <- function(
par,
samp,
gamma,
m = 50,            # Mini-batch size
...
) {
M <- floor(length(samp) / m)
for(j in 0:(M - 1)) {
i <- samp[(j * m + 1):(j * m + m)]
par <- par - gamma * grad_calc(X[i], Y[i], par[1], par[2], par[3], par[4])
}
par
}
SG_tracer <- tracer("par", N = 0)
SG_mini(initpar,
N = length(X),
gamma = 5e-2,
maxiter = 200,
cb = SG_tracer$tracer
)
summary(SG_tracer) %>% as_tibble() %>% rename("alpha" = par.1, "beta" = par.2, "gamma" = par.3, "rho" = par.4, "time" = .time) %>%
pivot_longer(cols = -time, names_to = "Parameter", values_to = "Estimate") %>%
ggplot(aes(x = time, y = Estimate, col = Parameter)) + geom_line(size = 1) +
geom_hline(data = trueval_tibble, aes(yintercept = Value, col = Parameter), linetype = "dashed", size = 1)
